# coding: utf-8

"""
    Resources and endpoints

    When I started SignWell in 2019, I saw there was a need for an alternative to the hard-to-use and expensive e-signature software already out there. Documents can be complicated enough, but getting a document signed shouldn't be complicated too.  At SignWell, we pride ourselves not only on the ease and affordability of our e-signature process but also on our personalized and industry-leading customer support â€” whether it's for individual use or larger team accounts, SignWell is here to help you feel comfortable and confident getting your documents signed.  The SignWell mission? Simplify how documents get signed for millions of people and businesses. We're excited to help you continue to move toward the future of paperless document signing.  Ruben Gamez Founder, SignWell

    The version of the OpenAPI document: 1
    Generated by: https://konfigthis.com
"""

from datetime import datetime, date
import typing
from enum import Enum
from typing_extensions import TypedDict, Literal, TYPE_CHECKING
from pydantic import BaseModel, Field, RootModel, ConfigDict


class FieldsMapItemItem(BaseModel):
    # Horizontal value in the coordinates of the field (in pixels). Coordinates are specific to the page where fields are located.
    x: typing.Union[int, float] = Field(alias='x')

    # Vertical value in the coordinates of the field (in pixels). Coordinates are specific to the page where fields are located.
    y: typing.Union[int, float] = Field(alias='y')

    # The page number within the file. If the page does not exist within the file then the field won't be created.
    page: int = Field(alias='page')

    # Unique identifier of the recipient assigned to the field. Recipients assigned to fields will be the only ones that will see and be able to complete those fields.
    recipient_id: str = Field(alias='recipient_id')

    # Field type of the field. Valid field types: initials, signatures, checkbox, date, and text. To autofill fields with contact data, use an autofill field type.
    type: Literal["initials", "signature", "checkbox", "date", "text", "autofill_company", "autofill_email", "autofill_first_name", "autofill_last_name", "autofill_name", "autofill_phone", "autofill_title", "autofill_date_signed"] = Field(alias='type')

    # Whether the field must be completed by the recipient. Defaults to `true` except for checkbox type fields.
    required: typing.Optional[bool] = Field(None, alias='required')

    # Text and Date fields only: label that is displayed when the field is empty.
    label: typing.Optional[str] = Field(None, alias='label')

    # Varies according to the field type. Text fields accept strings or numbers. Date fields accept Iso8601 date strings. CheckBoxes accept booleans. Signature and Initials fields can't be signed through API requests. Autofill text fields accept strings or numbers.
    value: typing.Optional[typing.Union[bool, date, datetime, dict, float, int, list, str, None]] = Field(None, alias='value')

    # Unique identifier of the field. Useful when needing to reference specific field values or update a document and its fields.
    api_id: typing.Optional[str] = Field(None, alias='api_id')

    # Text fields only: optional validation for field values. Valid values: numbers, letters, email_address, us_phone_number, us_zip_code, us_ssn, us_age, alphanumeric, us_bank_routing_number, us_bank_account.
    validation: typing.Optional[Literal["no_text_validation", "numbers", "letters", "email_address", "us_phone_number", "us_zip_code", "us_ssn", "us_age", "alphanumeric", "us_bank_routing_number", "us_bank_account_number"]] = Field(None, alias='validation')

    # Text fields only: whether the field width will stay fixed and text will display in multiple lines, rather than one long line. If set to `false` the field width will automatically grow horizontally to fit text on one line. Defaults to `false`.
    fixed_width: typing.Optional[bool] = Field(None, alias='fixed_width')

    # Date fields only: makes fields readonly and automatically populates with the date the recipient signed. Defaults to `false`.
    lock_sign_date: typing.Optional[bool] = Field(None, alias='lock_sign_date')

    # Date fields only: date format to use for the field. Valid values: MM/DD/YYYY, DD/MM/YYYY, YYYY/MM/DD, Month DD, YYYY, and MM/DD/YYYY hh:mm:ss a. Defaults to MM/DD/YYYY.
    date_format: typing.Optional[Literal["MM/DD/YYYY", "DD/MM/YYYY", "YYYY/MM/DD", "Month DD, YYYY", "MM/DD/YYYY hh:mm:ss a"]] = Field(None, alias='date_format')

    # Date fields only (text field formulas coming soon): formulas are a way to prefill fields with calculated future or past dates. Addition, subtraction, and parentheses are allowed. Valid event dates are `created_date`, `sent_date`, and `signed_date`. Valid time periods are `day`, `days`, `week`, `weeks`, `month`, and `months`. Example: `formula: \"sent_date + 10 days\"`. Use with `lock_sign_date` if you'd like to make the field readonly and prevent signers from choosing a different date.
    formula: typing.Optional[str] = Field(None, alias='formula')

    model_config = ConfigDict(
        protected_namespaces=(),
        arbitrary_types_allowed=True
    )
